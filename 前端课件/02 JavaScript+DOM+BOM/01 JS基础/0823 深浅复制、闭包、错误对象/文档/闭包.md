# 闭包

闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。

作用域的生命周期：

- 对于全局作用域，程序开始运行时 全局域创建，当程序结束时（关闭网页等），全局域释放。

- 对于函数级局部作用域，当函数调用时，作用域创建，函数执行完毕时，作用域释放。

# 变量的作用域

理解闭包，首先必须理解JavaScript变量作用域。变量的作用域无非就是两种：

- 全局作用域：全局变量
- 函数作用域：局部变量

JavaScript中，函数内部可以直接读取全局变量。

```JS
var n = 999;
function f1(){
  console.log(n);// 999
}
f1(); 
```

另一方面，在函数外部自然无法读取函数内的局部变量。

```JS
function f1() {
  var n = 999;
}
console.log(n); // ReferenceError: n is not defined
```

这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

```JS
function f1() {
  n = 999;
}
f1();
console.log(n); // 999
```

# 如何从外部读取局部变量？

出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。

```JS
function f1() {
  var a = 2;
  var b = 3;
  function f2() {
    var c = a + b;
    console.log('c=' + c);// C=5
  }
  f2();
}
f1();
```

上面代码中，函数`f2`就在函数`f1`内部，这时`f1`内部的所有局部变量，对`f2`都是可见的。但是反过来就不行，`f2`内部的局部变量，对`f1`就是不可见的。这就是 JavaScript 语言特有的"**链式作用域**"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然`f2`可以读取`f1`的局部变量，那么只要把`f2`作为返回值，我们不就可以在`f1`外部读取它的内部变量了吗！

```js
function f1() {
  var a = 2;
  var b = 3;
  function f2() {
    var c = a + b;
    return c;
  }
  var result = f2;
  return result;
}
var fn = f1();
console.log(fn());// 5
```

改写一下

```js
function f1() {
  var a = 2;
  var b = 3;
  function f2() {
    var c = a + b;
    return c;
  }
  //函数本身是一个函数对象，所以可以被当做值返回
  return f2;
}
var fn =  f1();
var value = fn();
console.log(value);
```

上面代码中，函数`f1`的返回值就是函数`f2`，由于`f2`可以读取`f1`的内部变量，所以就可以在外部获得`f1`的内部变量了。

当函数`f1`内部声明了一个函数`f2`，函数`f2`中使用了函数`f1`作用域中的变量，然后函数`f1`将函数`f2`作为返回值返回。那么函数`f1`执行完毕时，函数`f2`会继续存在，由于函数`f2`使用了函数`f1`的作用域，所以函数`f1`执行完毕时，作用域不会释放，而是被函数`f2`保留了。这就叫做函数f2闭包了函数f1的作用域。

# 闭包的概念

对于上边函数`f2`其实就是一个闭包 closure。即**能够读取其他函数内部变量的函数**。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“**定义在一个函数内部的函数，并且被函数外部所引用**”。

闭包也可以理解为：是指有权访问另一个函数作用域中变量的函数。

闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

# 闭包的用途

闭包的最大用处有两个：

- 可以访问外层函数内部的变量，
- 让函数内部的变量长时间的存储在内存中，即闭包可以使得它诞生环境一直存在。

请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。

```js
var add;
function f1() {
  var a = 2;
  function f2() {
     a += 10;
    console.log('a=' + a);
  }
  return f2;
}
var result = f1();
result(); // a=12
// 再次调用内部函数
result(); // a=22

// -----------------------------

function increase(start) {
  return function () {
    start++;
    return start;
  };
}

var inc = increase(5);
console.log(inc()); // 6
console.log(inc()); // 7
console.log(inc()); // 8
```

上面代码中，`start`是函数`increase`的内部变量。通过闭包，`start`的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包`inc`使得函数`increase`的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。

为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的`inc`）用到了外层变量（`start`），导致外层函数（`increase`）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。

闭包的另一个用处，是封装对象的私有属性和私有方法。

```js
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

上面代码中，函数`Person`的内部变量`_age`，通过闭包`getAge`和`setAge`，变成了返回对象`p1`的私有变量。

注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

# 使用闭包的注意

（1）由于闭包会使函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE浏览器中可能会导致内存泄露。

解决方案：在退出函数之前，将不使用的局部变量全部删除。 

（2）闭包会在父函数外部改变父函数内部变量的值。所以如果你把父函数当做对象使用，把闭包当做他的公有方法，把内部变量当作它的私有属性时，要注意不要随便改变父函数内部的变量值。