# 运算符
**运算符**（operator）也被称为**操作符**，是用于实现赋值、比较和执行算术运算等功能的符号。包括

- 算术运算符：`+` `-`  `*  ` `/` `%`
- 递增和递减运算符：`++`、`--`
- 关系运算符：`>` `<`  `<=` `>=` `==`  `===` `!=` `!==` 
- 逻辑运算符：`&&` `||` `!`
- 赋值运算符：`=`  `+=` `-=` `*=` `/=` `%=`
- 逗号运算符：`,`
- 一元加和减：`+ -`
- 圆括号运算符：`()`

JavaScript中的运算符根据其操作数的个数分为：一元运算符、二元运算符、三元运算符

- 一元运算符只对一个表达式执行操作，并产生一个新值；有一个操作数。有：`++ -- `、一元加和减。
- 二元运算符将两个表达式合成一个稍复杂的表达式，有两个操作数。有：算术、关系、逻辑、赋值等运算符。
- 三元运算符是条件判断运算符 `表达式1 ? 结果1 : 结果2` ,它将三个表达式合并成为一个表达式，有三个操作数。

# 表达式

表达式：是由数字、运算符、数字分组符号（括号）、自由变量等以能求得数字的有意义排列方法所得的组合。

- 0 != i % 10，a = 0,  a==0
- 5.0 + a
- (a - b) * c - 4
- i < 30 && i % 10 != 0 

表达式的类型和值

- 对表达式中操作数进行运算得到的结果称为表达式的值 
- 表达式的值的数据类型即为表达式的类型 

表达式的运算顺序

- 首先应按照运算符的优先级从高到低的顺序进行 
- 优先级相同的运算符按照事先约定的结合方向进行

# 算术运算符

算术运算符是用于执行两个变量或者数字的运算：`+` `-`  `*  ` `/` `%`

## 加法运算符 `+`

加法运算符（+）用于求两个操作数的和。

```js
var num1 = 6;
var num2 = 3;
var sum = num1 + num2;// sum=9

// 问题：请问 sum 结果为多少？
sum = sum + 6;
```

如果两个操作数都是数字，加法运算符执行加法运算并根据如下规则返回结果：

- 如果有任一操作数是 NaN，则返回 NaN；

如果有一个操作数是字符串，则要应用如下规则：

- 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；

- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。
- 如果有另一操作数是对象、数字或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取"undefined"和"null"。

```js
var num1 = 6;
var num2 = 3;
var sum = num1+num2;
console.log('sum');//'sum'
console.log('sum='+sum);//'sum=9' 打印sum变量的值不能把sum放在引号里面

var result1 = 'num1+num2的结果是'+ num1 + num2;//'num1+num2的结果是63'
var result2 = 'num1+num2的结果是'+ (num1 + num2);//'num1+num2的结果是9'
```

## 减法运算符 `-`

减法运算符（-）用于求两个操作数相减的结果

- 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数字，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。

```js
var result1 = 5 - true; // true 被转换为 1，所以结果是 4 
var result2 = NaN - 1; // NaN 
var result3 = 5 - 3; // 2 
var result4 = 5 - ""; // ""被转换为 0，所以结果是 5 
var result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3 
var result6 = 5 - null; // null 被转换为 0，所以结果是 5
```

## 乘法运算符 `*`

乘法运算符由一个星号（*）表示，可以用于计算两个数字的乘积。

```js
var num1 = 6;
var num2 = 3;
var sum = num1 * num2;// sum=18
```

乘法运算符在处理特殊值时也有一些特殊的行为：

- 如果操作数都是数字，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。 
- 如果有任一操作数是 NaN，则返回 NaN。 
- 如果有不是数字的操作数，则先在后台用 Number()将其转换为数字，然后再应用上述规则。

## 除法运算符 `/`

除法运算符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商。

```js
var num1 = 7;
var num2 = 3;
var sum = num1 / num2;// sum=2.5
```

除法运算符针对特殊值也有一些特殊的行为。

- 如果操作数都是数字，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。 
- 如果有任一操作数是 NaN，则返回 NaN。 
- 如果是 0 除以 0，则返回 NaN。  
- 如果有不是数字的操作数，则先在后台用 Number()函数将其转换为数字，然后再应用上述规则。

## 求余运算符 `%`

取模（余数）运算符由一个百分比符号（%）表示，比如：

```js
var num1 = 7;
var num2 = 3;
var sum = num1 % num2;// sum=1
```

取模运算符对特殊值也有一些特殊的行为：

- 如果操作数是数字，则执行常规除法运算，返回余数。
- 如果被除数是 0，除数不是 0，则返回 0。 
- 如果有不是数字的操作数，则先在后台用 Number()函数将其转换为数字，然后再应用上述规则。

## 取整运算 `Math.floor()`

`Math.floor()` 返回小于或等于一个给定数字的最大整数。

```js
var num1 = 7;
var num2 = 3;
var sum = Math.floor(num1 / num2);;// sum=2
```

# 递增和递减运算符

递增（++）和递减（ -- ）运算符有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。

注意：递增和递减运算符必须和变量配合使用。

## 前缀递增和递减运算符

前缀递增运算符会给数字加 1，把两个加号（++）放到变量前头即可：

```js
var count = 5;
++count; // 等价于 count = count + 1;
console.log(count);//6

var count = 5;
var res = ++count + 6;// 前缀递增：先加1，再使用
console.log(count);//6
console.log(res);//12
```

前缀递减运算符让一个数字减 1，要把两个减号（--）放到变量前头即可：

```js
var count = 5;
--count; // 等价于 count = count - 1;
console.log(count);//4

var count = 5;
var res = --count + 6;// 前缀递减：先减1，再使用
console.log(count);//4
console.log(res);//10
```

## 后缀递增和递减运算符

递增和递减的后缀版语法一样（分别是++和--），只不过要放在变量后面。

```js
var count = 5;
count++; // 等价于 count = count + 1;
console.log(count);//6

var count = 5;
var res = count++ + 6;// 后缀递增：先使用，再加1
console.log(count);//6
console.log(res);//11
```

```js
var count = 5;
count--; // 等价于 count = count - 1;
console.log(count);//4

var count = 5;
var res = count-- + 6;// 前缀递减：先使用，再减1
console.log(count);//4
console.log(res);//11
```

递增和递减运算符可以作用于任何值，不限于整数，字符串、布尔值、浮点值。遵循如下规则：

- 对于字符串，如果是有效的数字形式，则转换为数字再应用改变。变量类型从字符串变成数字。
- 对于字符串，如果不是有效的数字形式，则将变量的值设置为 NaN 。变量类型从字符串变成数字。
- 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数字。
- 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数字。
- 对于浮点值，加 1 或减 1。 

```js
var s1 = "2"; 
var s2 = "z"; 
var b = false; 
var f = 1.1; 

s1++; // 值变成数字 3 
s2++; // 值变成 NaN 
b++; // 值变成数字 1 
f--; // 值变成 0.10000000000000009（因为浮点数不精确）
```

## 总结

递增或递减运算单独使用时，前缀和后缀用法没有区别，与其他变量或者数字用在表达式中，运算结果不同：

- 前缀：先运算，再使用。

- 后缀：先使用，再运算。

运算是让变量的值 加1 或者 减1。后缀用法比较常用。

# 关系运算符

关系运算符执行比较两个值的操作，包括

- 比较运算符：小于（<）、大于（>）、小于等于（<=）、大于等于（>=）
- 相等运算符：等于（`==`）、不等于（`!=`）、全等（`===`）、不全等（`!==`）

比较运算符和相等运算符将两个值运算后，都返回一个布尔值 true 或者 false 作为运算结果，如下所示：

![图片1](https://i.loli.net/2021/11/28/u4ybh8kBx7oqKQZ.png)

## 比较运算符

比较运算符小于（<）、大于（>）、小于等于（<=）、大于等于（>=）应用到不同数据类型时也会发生类型转换和其他行为。

- 如果操作数都是数字，则执行数字比较。

- 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。

- 如果有任一操作数是数字，则将另一个操作数转换为数字，执行数字比较。

- 如果有任一操作数是布尔值，则将其转换为数字再执行比较。

在使用关系运算符比较两个字符串时，会发生一个有趣的现象。很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系运算符会比较字符串中对应字符的编码，而这些编码是数字。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：

```js
var result = "Brick" < "alphabet"; // true 
```

在这里，字符串"Brick"被认为小于字符串"alphabet"，因为字母 B 的编码是 66，字母 a 的编码是 97。要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式（全大写或全小写），然后再比较：

```js
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); // false 
```

将两个操作数都转换为小写，就能保证按照字母表顺序判定"alphabet"在"Brick"前头。另一个奇怪的现象是在比较两个数字字符串的时候，比如下面这个例子：

```js
var result = "23" < "3"; // true 
```

这里在比较字符串"23"和"3"时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符"2"的编码是 50，而字符"3"的编码是 51）。不过，如果有一个操作数是数字，那么比较的结果就对了：

```js
var result = "23" < 3; // false 
```

因为这次会将字符串"23"转换为数字 23，然后再跟 3 比较，结果当然对了。只要是数字和字符串比较，字符串就会先被转换为数字，然后进行数字比较。对于数字字符串而言，这样能保证结果正确。但如果字符串不能转换成数字呢？比如下面这个例子：

```js
var result = "a" < 3; // 因为"a"会转换为 NaN，所以结果是 false 
```

因为字符"a"不能转换成任何有意义的数字，所以只能转换为 NaN。这里有一个规则，即任何关系运算符在涉及比较 NaN 时都返回 false。这样一来，下面的例子有趣了：

```js
var result1 = NaN < 3; // false 
var result2 = NaN >= 3; // false 
```

在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较 NaN 时，
无论是小于还是大于等于，比较的结果都会返回 false

## 相等运算符

判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数字和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript 中的相等和不相等运算符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组运算符。第一组是等于（`==`）和不等于（`!=`），它们在比较之前执行转换。第二组是全等（`===`）和不全等（`!==`），它们在比较之前不执行转换。

### 等于和不等于

ECMAScript 中的等于运算符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于运算符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个运算符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。

在转换操作数的类型时，相等和不相等运算符遵循如下规则。

- 如果任一操作数是布尔值，则将其转换为数字再比较是否相等。false 转换为 0，true 转换为 1。 

- 如果一个操作数是字符串，另一个操作数是数字，则尝试将字符串转换为数字，再比较是否相等。
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。

在进行比较时，这两个运算符会遵循如下规则。

- null 和 undefined 相等。
- null 和 undefined 不能转换为其他类型的值再进行比较。
- 如果有任一操作数是 NaN，则相等运算符返回 false，不相等运算符返回 true。记住：即使两个操作数都是 NaN，相等运算符也返回 false，因为按照规则，NaN 不等于 NaN。 
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true。否则，两者不相等。

```js
//  表达式           结果
null == undefined 	true
"NaN" == NaN 				false
5 == NaN 						false
NaN == NaN 					false
NaN != NaN 					true
false == 0 					true
true == 1 					true
true == 2 					false
undefined == 0 			false
null == 0 					false
"5" == 5 						true
```

虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。

### 全等和不全等

全等和不全等运算符与相等和不相等运算符类似，只不过它们在比较相等时不转换操作数。全等运算符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：

```js
var result1 = ("55" == 55); // true，转换后相等，会把 '55'转为55，然后再比较大小
var result2 = ("55" === 55); // false，不相等，因为数据类型不同，不会把'55'转为55，字符串和数字不相等
```

不全等运算符用一个叹号和两个等于号（!==）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：

```js
var result1 = ("55" != 55); // false，转换后相等，会把'55'转为55，然后再比较大小
var result2 = ("55" !== 55); // true，不相等，因为数据类型不同，不会把'55'转为55，字符串和数字不相等

// ("55" !== 55) 等价于 问：“字符串 55 和数字 55 有区别吗？” 答案是“有”（true）。
```



> 注意：由于相等和不相等运算符存在类型转换问题，因此推荐使用**全等**和**不全等**运算符。这样有助于在代码中保持数据类型的完整性。

# 逻辑运算符

逻辑运算符逻辑非`!`、逻辑与 `&&` 和逻辑或 `||` 

逻辑运算符一般是用于对boolean型结果的表达式进行运算，运算结果是boolean型。

## 逻辑与

逻辑与运算符由两个和号（&&）表示，应用到两个值，如下所示：

```js
var result = true && false; // false
```

逻辑与运算符遵循如下真值表：

| 第一个操作数 | 第二个操作数 | 结果  |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | false |
| false        | true         | false |
| false        | false        | false |

逻辑与的运算：**一假即假**。两个操作数有一个为假（false），运算结果就位假（false）。

逻辑与运算符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。

- 如果第一个操作数是对象，则返回第二个操作数。

- 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。

- 如果两个操作数都是对象，则返回第二个操作数。

- 如果有一个操作数是 null，则返回 null。 

- 如果有一个操作数是 NaN，则返回 NaN。 

- 如果有一个操作数是 undefined，则返回 undefined。

## 逻辑或

逻辑或运算符由两个管道符（||）表示，比如：

```js
var result = true || false; //true
```

逻辑或运算符遵循如下真值表：

| 第一个操作数 | 第二个操作数 | 结果  |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | true  |
| false        | true         | true  |
| false        | false        | false |

逻辑与的运算：**一真即真**。两个操作数有一个为真（true），运算结果就位真（true）。

与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或运算符也不一定返回布尔值。它遵循如下规则。

- 如果第一个操作数是对象，则返回第一个操作数。
- 如果第一个操作数求值为 false，则返回第二个操作数。
- 如果两个操作数都是对象，则返回第一个操作数。
- 如果两个操作数都是 null，则返回 null。 
- 如果两个操作数都是 NaN，则返回 NaN。 
- 如果两个操作数都是 undefined，则返回 undefined。

## 逻辑非

逻辑非运算符由一个叹号（!）表示，可应用给任何值。这个运算符始终返回布尔值，无论应用到的是什么数据类型。逻辑非运算符首先将操作数转换为布尔值，然后再对其取反。

逻辑非运算符会遵循如下规则。

- 如果操作数是对象，则返回 false。 

- 如果操作数是空字符串，则返回 true。 

- 如果操作数是非空字符串，则返回 false。 

- 如果操作数是数字 0，则返回 true。 

- 如果操作数是非 0 数字（包括 Infinity），则返回 false。 

- 如果操作数是 null，则返回 true。 

- 如果操作数是 NaN，则返回 true。 

- 如果操作数是 undefined，则返回 true。

```js
console.log(!""); // true 
console.log(!"blue"); // false
console.log(!0); // true 
console.log(!12345); // false 
console.log(!false); // true 
console.log(!null); // true 
console.log(!NaN); // true 
console.log(!undefined); // true 
```

逻辑非运算符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：

```js
console.log(!!"blue"); // true 
console.log(!!0); // false 
console.log(!!NaN); // false 
console.log(!!""); // false 
console.log(!!12345); // true
```

## 短路运算

短路运算的原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。

### 短路与

**逻辑与也叫短路与**：

逻辑与运算符是一种短路运算符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与运算符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。

```js
var count = 5;
var res = count>6 && count++;
console.log(res);// false
console.log(count);// 5
```

对于数字的运算：

- 如果第一个数字为真，则返回第二个数字
- 如果第一个数字为假，则返回第一个数字

```js
console.log(12 && 24);//24
console.log(12 && 24 && 36);//36
console.log(0 && 24);//0
```

### 短路或

**逻辑或也叫短路或**：

同样与逻辑与类似，逻辑或运算符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。

```js
var count = 5;
var res = count<6 || count++;
console.log(res);// true
console.log(count);// 5
```

如果第一个操作数求值为 false，则返回第二个操作数。第二个操作数可以是任意类型，比如：数字、布尔、字符串、对象等

```js
var count = 5;
var res = count>6 || count++;
console.log(res);// 5
console.log(count);// 6

console.log(12 || 24);//12
console.log(12 || 24 || 36);//12
console.log(0 || 24);//24
```

利用这个行为，可以避免给变量赋值 null 或 undefined。比如：

```js
var res = page || 1;//如果page的值为null或者undefined，把数字1赋值给
```

# 赋值运算符

简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量。

```js
var num1 = 6;
var num2 = 3;
```

复合赋值使用算术运算符后跟等于号（=）表示。

- 乘后赋值（*=） 

- 除后赋值（/=） 

- 取模后赋值（%=） 

- 加后赋值（+=） 
- 减后赋值（-=）

这些赋值运算符是类似如下常见赋值操作的简写形式：

```js
var num = 10; 
num = num + 10; 

//以上代码的第二行可以通过复合赋值来完成：
var num = 10; 
num += 10;
```

![image-20211128221827753](https://i.loli.net/2021/11/28/SbhvL7nIqU2KgOd.png)

# 逗号运算符 

逗号运算符（`,`）可以用来在一条语句中执行多个操作，如下所示：

```js
var num1 = 1, num2 = 2, num3 = 3; 
```

在一条语句中同时声明多个变量是逗号运算符最常用的场景。不过，也可以使用逗号运算符来辅助赋值。在赋值时使用逗号运算符分隔值，最终会返回表达式中最后一个值：

```js
var num = (5, 1, 4, 8, 0); // num 的值为 0 
```

在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号运算符的这种使用场景并不多见，但这种行为的确存在。

# 一元加和减

一元加和减运算符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。

## 一元加

一元加由一个加号（+）表示，放在变量前头，对数字没有任何影响：

```js
var num = 25; 
num = +num; 
console.log(num); // 25
```

如果将一元加应用到非数字，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析。

```js
var s1 = "01"; 
var s2 = "1.1";
var s3 = "z"; 
var b = false; 
var f = 1.1; 
s1 = +s1; // 值变成数字 1 
s2 = +s2; // 值变成数字 1.1 
s3 = +s3; // 值变成 NaN 
b = +b; // 值变成数字 0 
f = +f; // 不变，还是 1.1 
```

## 一元减

一元减由一个减号（-）表示，放在变量前头，主要用于把数字变成负值，如把 1 转换为负数 -1。示例如下：

```js
var num = 25; 
num = -num; 
console.log(num); // -25 
```

对数字使用一元减会将其变成相应的负值。在应用到非数字时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：

```js
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
s1 = -s1; // 值变成数字-1 
s2 = -s2; // 值变成数字-1.1 
s3 = -s3; // 值变成 NaN 
b = -b; // 值变成数字 0 
f = -f; // 变成-1.1 
```

一元加和减运算符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。

# 圆括号运算符

圆括号运算符 `( )` 用于控制表达式中的运算优先级，括号内的运算会优先执行。

```js
var a = (2 + 3) * 5;
console.log(a);//30
```

# 运算符优先级

**运算符的优先级**决定了表达式中运算执行的先后顺序。优先级高的运算符会作为优先级低的运算符的运算符。

| 优先级 | 运算符              | 顺序                                   |
| ------ | ------------------- | -------------------------------------- |
| 1      | `()`                | 分组运算                               |
| 2      | `++ --`             | 后置递增、递减                         |
| 3      | `++ -- ! + -`       | 前置递增、递减、逻辑非、一元加、一元减 |
| 4      | `* / % `            | 乘、除、余                             |
| 5      | `+ -`               | 加、减                                 |
| 6      | `> < <= >=`         | 关系运算符                             |
| 7      | ` == != === !==`    | 相等运算符                             |
| 8      | `&& `               | 逻辑与                                 |
| 9      | `||`                | 逻辑或                                 |
| 10     | `= += -= *= /= %= ` | 赋值运算符                             |
| 11     | `,`                 | 逗号运算符                             |

# 练习

## 算术运算符练习：

- 从键盘输入小明的语数外成绩，输出  小明的总分是
- 定义三个变量，从键盘输入值给他们，然后使用alert()顺序输出他们，保留三位小数
- 定义常量PI=3.1415926，从键盘输入 半径 r；输出圆的面积（保留2位小数）
- 从键盘获取 圆的半径r， 圆柱高h，定义一个圆周率常量 PI = 3.1415926 ，求出圆周长，园面积，圆柱体积 取小数点后两位 有文字说明，例如：圆周长 = xxx.xx 
- 从键盘输入一个四位数的正整数，输出他的个，十，百，千位上的数字

## 递增和递减练习：

```js
var a = 3;
var b = 2;
var res1 = (a++)*(--b) + (--a)/(b++); 
//请推断res1, a, b此时的值。
var res2 = (--a)%(b++) + (++a)*(b--) - (a--);
//请推断res2, a, b此时的值。

var x = 2; 
var y = 3;
var res3 = (x++)*2+(--y)%3+(--x)/4+(++y)*3;
var res4 = (--x)/3-(y++)*2+(x++)%2-(y--)%3;
//请推断res3, res4, x, y此时的值。

var a = 2; 
var b = 3;
var res1 = ((a++)+(++b))*2+(--a)%(b++)-(++a)*3+(--b)/(--a);
//请推断res1, a, b此时的值。
```

## 短路练习：

```js
var a = 2;
var b = 3;

bool flag1 = ++a > 1 || --b < 5;
console.log(flag1);
console.log(a);
console.log(b);


var b1 = true;
var b2 = false;
var b3 = b1 && b2;
console.log(b3);
console.log(true && false && true && true);

var b4 = b1 || b2;
console.log(b4);
console.log(true || false || false);
console.log(!true);

var a = 3;
var b = 2;
var b1 = (a++)>(--b) && (--a)%(b++)==1 && (a--)<(b--);
console.log(b1, a, b);

var a = 3;
var b = 2;
var b2 = (a--)/(b++)<2 || (--a)*(--b)!=4 || (a++)%(b--)==2;
console.log(b2, a, b);
```

